{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\n\nfunction observerComponentNameFor(baseComponentName) {\n  return \"observer\".concat(baseComponentName);\n}\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\n\n\nvar ObjectToBeRetainedByReact =\n/** @class */\nfunction () {\n  function ObjectToBeRetainedByReact() {}\n\n  return ObjectToBeRetainedByReact;\n}();\n\nfunction objectToBeRetainedByReactFactory() {\n  return new ObjectToBeRetainedByReact();\n}\n\nexport function useObserver(fn, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n\n  if (isUsingStaticRendering()) {\n    return fn();\n  }\n\n  var _a = __read(React.useState(objectToBeRetainedByReactFactory), 1),\n      objectRetainedByReact = _a[0]; // Force update, see #2982\n\n\n  var _b = __read(React.useState(), 2),\n      setState = _b[1];\n\n  var forceUpdate = function () {\n    return setState([]);\n  }; // StrictMode/ConcurrentMode/Suspense may mean that our component is\n  // rendered and abandoned multiple times, so we need to track leaked\n  // Reactions.\n\n\n  var admRef = React.useRef(null);\n\n  if (!admRef.current) {\n    // First render\n    admRef.current = {\n      reaction: null,\n      mounted: false,\n      changedBeforeMount: false\n    };\n  }\n\n  var adm = admRef.current;\n\n  if (!adm.reaction) {\n    // First render or component was not committed and reaction was disposed by registry\n    adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n      // Observable has changed, meaning we want to re-render\n      // BUT if we're a component that hasn't yet got to the useEffect()\n      // stage, we might be a component that _started_ to render, but\n      // got dropped, and we don't want to make state changes then.\n      // (It triggers warnings in StrictMode, for a start.)\n      if (adm.mounted) {\n        // We have reached useEffect(), so we're mounted, and can trigger an update\n        forceUpdate();\n      } else {\n        // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n        // when (and if) useEffect() arrives.\n        adm.changedBeforeMount = true;\n      }\n    });\n    observerFinalizationRegistry.register(objectRetainedByReact, adm, adm);\n  }\n\n  React.useDebugValue(adm.reaction, printDebugValue);\n  React.useEffect(function () {\n    observerFinalizationRegistry.unregister(adm);\n    adm.mounted = true;\n\n    if (adm.reaction) {\n      if (adm.changedBeforeMount) {\n        // Got a change before mount, force an update\n        adm.changedBeforeMount = false;\n        forceUpdate();\n      }\n    } else {\n      // The reaction we set up in our render has been disposed.\n      // This can be due to bad timings of renderings, e.g. our\n      // component was paused for a _very_ long time, and our\n      // reaction got cleaned up\n      // Re-create the reaction\n      adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n        // We've definitely already been mounted at this point\n        forceUpdate();\n      });\n      forceUpdate();\n    }\n\n    return function () {\n      adm.reaction.dispose();\n      adm.reaction = null;\n      adm.mounted = false;\n      adm.changedBeforeMount = false;\n    };\n  }, []); // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n\n  var rendering;\n  var exception;\n  adm.reaction.track(function () {\n    try {\n      rendering = fn();\n    } catch (e) {\n      exception = e;\n    }\n  });\n\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n\n  return rendering;\n}","map":{"version":3,"sources":["../src/useObserver.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\".concat(baseComponentName);\n}\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\nvar ObjectToBeRetainedByReact = /** @class */ (function () {\n    function ObjectToBeRetainedByReact() {\n    }\n    return ObjectToBeRetainedByReact;\n}());\nfunction objectToBeRetainedByReactFactory() {\n    return new ObjectToBeRetainedByReact();\n}\nexport function useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (isUsingStaticRendering()) {\n        return fn();\n    }\n    var _a = __read(React.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a[0];\n    // Force update, see #2982\n    var _b = __read(React.useState(), 2), setState = _b[1];\n    var forceUpdate = function () { return setState([]); };\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var admRef = React.useRef(null);\n    if (!admRef.current) {\n        // First render\n        admRef.current = {\n            reaction: null,\n            mounted: false,\n            changedBeforeMount: false\n        };\n    }\n    var adm = admRef.current;\n    if (!adm.reaction) {\n        // First render or component was not committed and reaction was disposed by registry\n        adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (adm.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                forceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.\n                adm.changedBeforeMount = true;\n            }\n        });\n        observerFinalizationRegistry.register(objectRetainedByReact, adm, adm);\n    }\n    React.useDebugValue(adm.reaction, printDebugValue);\n    React.useEffect(function () {\n        observerFinalizationRegistry.unregister(adm);\n        adm.mounted = true;\n        if (adm.reaction) {\n            if (adm.changedBeforeMount) {\n                // Got a change before mount, force an update\n                adm.changedBeforeMount = false;\n                forceUpdate();\n            }\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This can be due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up\n            // Re-create the reaction\n            adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n                // We've definitely already been mounted at this point\n                forceUpdate();\n            });\n            forceUpdate();\n        }\n        return function () {\n            adm.reaction.dispose();\n            adm.reaction = null;\n            adm.mounted = false;\n            adm.changedBeforeMount = false;\n        };\n    }, []);\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    var rendering;\n    var exception;\n    adm.reaction.track(function () {\n        try {\n            rendering = fn();\n        }\n        catch (e) {\n            exception = e;\n        }\n    });\n    if (exception) {\n        throw exception; // re-throw any exceptions caught during rendering\n    }\n    return rendering;\n}\n//# sourceMappingURL=useObserver.js.map"]},"metadata":{},"sourceType":"module"}